// Code generated by goa v3.24.1, DO NOT EDIT.
//
// graph HTTP client types
//
// Command:
// $ goa gen github.com/aditnikel/grapgraph/design

package client

import (
	graph "github.com/aditnikel/grapgraph/gen/graph"
	goa "goa.design/goa/v3/pkg"
)

// PostSubgraphRequestBody is the type of the "graph" service "post_subgraph"
// endpoint HTTP request body.
type PostSubgraphRequestBody struct {
	// The starting node for the traversal.
	Root *struct {
		// Type of the root node (usually USER).
		Type string `form:"type" json:"type" xml:"type"`
		// The unique key of the root node.
		Key string `form:"key" json:"key" xml:"key"`
	} `form:"root" json:"root" xml:"root"`
	// Number of hops to traverse (1-3).
	Hops int `form:"hops" json:"hops" xml:"hops"`
	// Filter to only include these relationship types.
	EdgeTypes []string `form:"edge_types,omitempty" json:"edge_types,omitempty" xml:"edge_types,omitempty"`
	// Resource budget for the response.
	Limit *struct {
		// Maximum number of nodes to return.
		MaxNodes int `form:"max_nodes" json:"max_nodes" xml:"max_nodes"`
		// Maximum number of edges to return.
		MaxEdges int `form:"max_edges" json:"max_edges" xml:"max_edges"`
	} `form:"limit" json:"limit" xml:"limit"`
}

// PostManualEdgeRequestBody is the type of the "graph" service
// "post_manual_edge" endpoint HTTP request body.
type PostManualEdgeRequestBody struct {
	// Source node.
	From *NodeRefRequestBody `form:"from" json:"from" xml:"from"`
	// Target node.
	To *NodeRefRequestBody `form:"to" json:"to" xml:"to"`
	// Relationship type (e.g. PAYMENT, MANUAL).
	EdgeType string `form:"edge_type" json:"edge_type" xml:"edge_type"`
}

// GetMetadataResponseBody is the type of the "graph" service "get_metadata"
// endpoint HTTP response body.
type GetMetadataResponseBody struct {
	// All valid entity types.
	NodeTypes []string `form:"node_types,omitempty" json:"node_types,omitempty" xml:"node_types,omitempty"`
	// All valid event types.
	EdgeTypes []string `form:"edge_types,omitempty" json:"edge_types,omitempty" xml:"edge_types,omitempty"`
}

// PostSubgraphResponseBody is the type of the "graph" service "post_subgraph"
// endpoint HTTP response body.
type PostSubgraphResponseBody struct {
	// Format version of the response.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
	// The ID of the requested starting node.
	Root *string `form:"root,omitempty" json:"root,omitempty" xml:"root,omitempty"`
	// List of all entities in the network.
	Nodes []*GraphNodeResponseBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// List of all connections found.
	Edges []*GraphEdgeResponseBody `form:"edges,omitempty" json:"edges,omitempty" xml:"edges,omitempty"`
	// Indicates if the result was clipped by performance budgets.
	Truncated *bool `form:"truncated,omitempty" json:"truncated,omitempty" xml:"truncated,omitempty"`
}

// PostManualEdgeResponseBody is the type of the "graph" service
// "post_manual_edge" endpoint HTTP response body.
type PostManualEdgeResponseBody struct {
	// Unique ID for the specific relationship.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of connection (e.g. PAYMENT).
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// ID of the source node.
	From *string `form:"from,omitempty" json:"from,omitempty" xml:"from,omitempty"`
	// ID of the target node.
	To *string `form:"to,omitempty" json:"to,omitempty" xml:"to,omitempty"`
	// Whether the relationship has a specific flow direction.
	Directed *bool `form:"directed,omitempty" json:"directed,omitempty" xml:"directed,omitempty"`
	// Whether the relationship was manually added.
	Manual *bool `form:"manual,omitempty" json:"manual,omitempty" xml:"manual,omitempty"`
}

// GraphNodeResponseBody is used to define fields on response body types.
type GraphNodeResponseBody struct {
	// Stable ID generated for visualization.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The category of the entity.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The domain-specific key (e.g. u_123).
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
	// Human-friendly display name.
	Label *string `form:"label,omitempty" json:"label,omitempty" xml:"label,omitempty"`
	// Additional key-value properties.
	Props map[string]any `form:"props,omitempty" json:"props,omitempty" xml:"props,omitempty"`
}

// GraphEdgeResponseBody is used to define fields on response body types.
type GraphEdgeResponseBody struct {
	// Unique ID for the specific relationship.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of connection (e.g. PAYMENT).
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// ID of the source node.
	From *string `form:"from,omitempty" json:"from,omitempty" xml:"from,omitempty"`
	// ID of the target node.
	To *string `form:"to,omitempty" json:"to,omitempty" xml:"to,omitempty"`
	// Whether the relationship has a specific flow direction.
	Directed *bool `form:"directed,omitempty" json:"directed,omitempty" xml:"directed,omitempty"`
	// Whether the relationship was manually added.
	Manual *bool `form:"manual,omitempty" json:"manual,omitempty" xml:"manual,omitempty"`
}

// NodeRefRequestBody is used to define fields on request body types.
type NodeRefRequestBody struct {
	// Type of the node.
	Type string `form:"type" json:"type" xml:"type"`
	// The unique key of the node.
	Key string `form:"key" json:"key" xml:"key"`
}

// NewPostSubgraphRequestBody builds the HTTP request body from the payload of
// the "post_subgraph" endpoint of the "graph" service.
func NewPostSubgraphRequestBody(p *graph.SubgraphRequest) *PostSubgraphRequestBody {
	body := &PostSubgraphRequestBody{
		Hops: p.Hops,
	}
	if p.Root != nil {
		body.Root = &struct {
			// Type of the root node (usually USER).
			Type string `form:"type" json:"type" xml:"type"`
			// The unique key of the root node.
			Key string `form:"key" json:"key" xml:"key"`
		}{
			Type: p.Root.Type,
			Key:  p.Root.Key,
		}
	}
	{
		var zero int
		if body.Hops == zero {
			body.Hops = 2
		}
	}
	if p.EdgeTypes != nil {
		body.EdgeTypes = make([]string, len(p.EdgeTypes))
		for i, val := range p.EdgeTypes {
			body.EdgeTypes[i] = val
		}
	}
	if p.Limit != nil {
		body.Limit = &struct {
			// Maximum number of nodes to return.
			MaxNodes int `form:"max_nodes" json:"max_nodes" xml:"max_nodes"`
			// Maximum number of edges to return.
			MaxEdges int `form:"max_edges" json:"max_edges" xml:"max_edges"`
		}{
			MaxNodes: p.Limit.MaxNodes,
			MaxEdges: p.Limit.MaxEdges,
		}
	}
	return body
}

// NewPostManualEdgeRequestBody builds the HTTP request body from the payload
// of the "post_manual_edge" endpoint of the "graph" service.
func NewPostManualEdgeRequestBody(p *graph.ManualEdgeRequest) *PostManualEdgeRequestBody {
	body := &PostManualEdgeRequestBody{
		EdgeType: p.EdgeType,
	}
	if p.From != nil {
		body.From = marshalGraphNodeRefToNodeRefRequestBody(p.From)
	}
	if p.To != nil {
		body.To = marshalGraphNodeRefToNodeRefRequestBody(p.To)
	}
	return body
}

// NewGetMetadataMetadataResponseOK builds a "graph" service "get_metadata"
// endpoint result from a HTTP "OK" response.
func NewGetMetadataMetadataResponseOK(body *GetMetadataResponseBody) *graph.MetadataResponse {
	v := &graph.MetadataResponse{}
	v.NodeTypes = make([]string, len(body.NodeTypes))
	for i, val := range body.NodeTypes {
		v.NodeTypes[i] = val
	}
	v.EdgeTypes = make([]string, len(body.EdgeTypes))
	for i, val := range body.EdgeTypes {
		v.EdgeTypes[i] = val
	}

	return v
}

// NewPostSubgraphSubgraphResponseOK builds a "graph" service "post_subgraph"
// endpoint result from a HTTP "OK" response.
func NewPostSubgraphSubgraphResponseOK(body *PostSubgraphResponseBody) *graph.SubgraphResponse {
	v := &graph.SubgraphResponse{
		Version:   *body.Version,
		Root:      *body.Root,
		Truncated: *body.Truncated,
	}
	v.Nodes = make([]*graph.GraphNode, len(body.Nodes))
	for i, val := range body.Nodes {
		if val == nil {
			v.Nodes[i] = nil
			continue
		}
		v.Nodes[i] = unmarshalGraphNodeResponseBodyToGraphGraphNode(val)
	}
	v.Edges = make([]*graph.GraphEdge, len(body.Edges))
	for i, val := range body.Edges {
		if val == nil {
			v.Edges[i] = nil
			continue
		}
		v.Edges[i] = unmarshalGraphEdgeResponseBodyToGraphGraphEdge(val)
	}

	return v
}

// NewPostSubgraphBadRequest builds a graph service post_subgraph endpoint
// bad_request error.
func NewPostSubgraphBadRequest(body string) graph.BadRequest {
	v := graph.BadRequest(body)

	return v
}

// NewPostManualEdgeGraphEdgeCreated builds a "graph" service
// "post_manual_edge" endpoint result from a HTTP "Created" response.
func NewPostManualEdgeGraphEdgeCreated(body *PostManualEdgeResponseBody) *graph.GraphEdge {
	v := &graph.GraphEdge{
		ID:       *body.ID,
		Type:     *body.Type,
		From:     *body.From,
		To:       *body.To,
		Directed: *body.Directed,
		Manual:   *body.Manual,
	}

	return v
}

// NewPostManualEdgeBadRequest builds a graph service post_manual_edge endpoint
// bad_request error.
func NewPostManualEdgeBadRequest(body string) graph.BadRequest {
	v := graph.BadRequest(body)

	return v
}

// ValidateGetMetadataResponseBody runs the validations defined on
// get_metadata_response_body
func ValidateGetMetadataResponseBody(body *GetMetadataResponseBody) (err error) {
	if body.NodeTypes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_types", "body"))
	}
	if body.EdgeTypes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("edge_types", "body"))
	}
	return
}

// ValidatePostSubgraphResponseBody runs the validations defined on
// post_subgraph_response_body
func ValidatePostSubgraphResponseBody(body *PostSubgraphResponseBody) (err error) {
	if body.Version == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("version", "body"))
	}
	if body.Root == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("root", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.Edges == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("edges", "body"))
	}
	if body.Truncated == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("truncated", "body"))
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateGraphNodeResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Edges {
		if e != nil {
			if err2 := ValidateGraphEdgeResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidatePostManualEdgeResponseBody runs the validations defined on
// post_manual_edge_response_body
func ValidatePostManualEdgeResponseBody(body *PostManualEdgeResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.From == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("from", "body"))
	}
	if body.To == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("to", "body"))
	}
	if body.Directed == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("directed", "body"))
	}
	if body.Manual == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("manual", "body"))
	}
	return
}

// ValidateGraphNodeResponseBody runs the validations defined on
// GraphNodeResponseBody
func ValidateGraphNodeResponseBody(body *GraphNodeResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	if body.Label == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("label", "body"))
	}
	return
}

// ValidateGraphEdgeResponseBody runs the validations defined on
// GraphEdgeResponseBody
func ValidateGraphEdgeResponseBody(body *GraphEdgeResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.From == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("from", "body"))
	}
	if body.To == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("to", "body"))
	}
	if body.Directed == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("directed", "body"))
	}
	if body.Manual == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("manual", "body"))
	}
	return
}

// Code generated by goa v3.24.1, DO NOT EDIT.
//
// graph HTTP client types
//
// Command:
// $ goa gen github.com/aditnikel/grapgraph/design

package client

import (
	graph "github.com/aditnikel/grapgraph/gen/graph"
	goa "goa.design/goa/v3/pkg"
)

// PostSubgraphRequestBody is the type of the "graph" service "post_subgraph"
// endpoint HTTP request body.
type PostSubgraphRequestBody struct {
	// The starting node for the traversal.
	Root *struct {
		// Type of the root node (usually USER).
		Type string `form:"type" json:"type" xml:"type"`
		// The unique key of the root node.
		Key string `form:"key" json:"key" xml:"key"`
	} `form:"root" json:"root" xml:"root"`
	// Number of hops to traverse (1-3).
	Hops int `form:"hops" json:"hops" xml:"hops"`
	// Optional time range to filter relationship metrics.
	TimeWindow *struct {
		// Start of the window (RFC3339).
		From string `form:"from" json:"from" xml:"from"`
		// End of the window (RFC3339).
		To string `form:"to" json:"to" xml:"to"`
	} `form:"time_window" json:"time_window" xml:"time_window"`
	// Filter to only include these relationship types.
	EdgeTypes []string `form:"edge_types,omitempty" json:"edge_types,omitempty" xml:"edge_types,omitempty"`
	// Minimum number of aggregate events to include an edge.
	MinEventCount int `form:"min_event_count" json:"min_event_count" xml:"min_event_count"`
	// Metric used to sort and truncate neighbor nodes.
	RankNeighborsBy string `form:"rank_neighbors_by" json:"rank_neighbors_by" xml:"rank_neighbors_by"`
	// Resource budget for the response.
	Limit *struct {
		// Maximum number of nodes to return.
		MaxNodes int `form:"max_nodes" json:"max_nodes" xml:"max_nodes"`
		// Maximum number of edges to return.
		MaxEdges int `form:"max_edges" json:"max_edges" xml:"max_edges"`
	} `form:"limit" json:"limit" xml:"limit"`
}

// GetMetadataResponseBody is the type of the "graph" service "get_metadata"
// endpoint HTTP response body.
type GetMetadataResponseBody struct {
	// All valid entity types.
	NodeTypes []string `form:"node_types,omitempty" json:"node_types,omitempty" xml:"node_types,omitempty"`
	// All valid event types.
	EdgeTypes []string `form:"edge_types,omitempty" json:"edge_types,omitempty" xml:"edge_types,omitempty"`
	// Valid keys for the rank_neighbors_by parameter.
	RankMetrics []string `form:"rank_metrics,omitempty" json:"rank_metrics,omitempty" xml:"rank_metrics,omitempty"`
}

// PostSubgraphResponseBody is the type of the "graph" service "post_subgraph"
// endpoint HTTP response body.
type PostSubgraphResponseBody struct {
	// Format version of the response.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
	// The ID of the requested starting node.
	Root *string `form:"root,omitempty" json:"root,omitempty" xml:"root,omitempty"`
	// List of all entities in the network.
	Nodes []*GraphNodeResponseBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// List of all connections found.
	Edges []*GraphEdgeResponseBody `form:"edges,omitempty" json:"edges,omitempty" xml:"edges,omitempty"`
	// Indicates if the result was clipped by performance budgets.
	Truncated *bool `form:"truncated,omitempty" json:"truncated,omitempty" xml:"truncated,omitempty"`
}

// GraphNodeResponseBody is used to define fields on response body types.
type GraphNodeResponseBody struct {
	// Stable ID generated for visualization.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The category of the entity.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The domain-specific key (e.g. u_123).
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
	// Human-friendly display name.
	Label *string `form:"label,omitempty" json:"label,omitempty" xml:"label,omitempty"`
	// Additional key-value properties.
	Props map[string]any `form:"props,omitempty" json:"props,omitempty" xml:"props,omitempty"`
}

// GraphEdgeResponseBody is used to define fields on response body types.
type GraphEdgeResponseBody struct {
	// Unique ID for the specific relationship.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of connection (e.g. PAYMENT).
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// ID of the source node.
	From *string `form:"from,omitempty" json:"from,omitempty" xml:"from,omitempty"`
	// ID of the target node.
	To *string `form:"to,omitempty" json:"to,omitempty" xml:"to,omitempty"`
	// Whether the relationship has a specific flow direction.
	Directed *bool `form:"directed,omitempty" json:"directed,omitempty" xml:"directed,omitempty"`
	// Statistical snapshots (count, amount, first_seen, etc).
	Metrics map[string]any `form:"metrics,omitempty" json:"metrics,omitempty" xml:"metrics,omitempty"`
}

// NewPostSubgraphRequestBody builds the HTTP request body from the payload of
// the "post_subgraph" endpoint of the "graph" service.
func NewPostSubgraphRequestBody(p *graph.SubgraphRequest) *PostSubgraphRequestBody {
	body := &PostSubgraphRequestBody{
		Hops:            p.Hops,
		MinEventCount:   p.MinEventCount,
		RankNeighborsBy: p.RankNeighborsBy,
	}
	if p.Root != nil {
		body.Root = &struct {
			// Type of the root node (usually USER).
			Type string `form:"type" json:"type" xml:"type"`
			// The unique key of the root node.
			Key string `form:"key" json:"key" xml:"key"`
		}{
			Type: p.Root.Type,
			Key:  p.Root.Key,
		}
	}
	{
		var zero int
		if body.Hops == zero {
			body.Hops = 2
		}
	}
	if p.TimeWindow != nil {
		body.TimeWindow = &struct {
			// Start of the window (RFC3339).
			From string `form:"from" json:"from" xml:"from"`
			// End of the window (RFC3339).
			To string `form:"to" json:"to" xml:"to"`
		}{
			From: p.TimeWindow.From,
			To:   p.TimeWindow.To,
		}
	}
	if p.EdgeTypes != nil {
		body.EdgeTypes = make([]string, len(p.EdgeTypes))
		for i, val := range p.EdgeTypes {
			body.EdgeTypes[i] = val
		}
	}
	{
		var zero int
		if body.MinEventCount == zero {
			body.MinEventCount = 1
		}
	}
	{
		var zero string
		if body.RankNeighborsBy == zero {
			body.RankNeighborsBy = "event_count_30d"
		}
	}
	if p.Limit != nil {
		body.Limit = &struct {
			// Maximum number of nodes to return.
			MaxNodes int `form:"max_nodes" json:"max_nodes" xml:"max_nodes"`
			// Maximum number of edges to return.
			MaxEdges int `form:"max_edges" json:"max_edges" xml:"max_edges"`
		}{
			MaxNodes: p.Limit.MaxNodes,
			MaxEdges: p.Limit.MaxEdges,
		}
	}
	return body
}

// NewGetMetadataMetadataResponseOK builds a "graph" service "get_metadata"
// endpoint result from a HTTP "OK" response.
func NewGetMetadataMetadataResponseOK(body *GetMetadataResponseBody) *graph.MetadataResponse {
	v := &graph.MetadataResponse{}
	v.NodeTypes = make([]string, len(body.NodeTypes))
	for i, val := range body.NodeTypes {
		v.NodeTypes[i] = val
	}
	v.EdgeTypes = make([]string, len(body.EdgeTypes))
	for i, val := range body.EdgeTypes {
		v.EdgeTypes[i] = val
	}
	v.RankMetrics = make([]string, len(body.RankMetrics))
	for i, val := range body.RankMetrics {
		v.RankMetrics[i] = val
	}

	return v
}

// NewPostSubgraphSubgraphResponseOK builds a "graph" service "post_subgraph"
// endpoint result from a HTTP "OK" response.
func NewPostSubgraphSubgraphResponseOK(body *PostSubgraphResponseBody) *graph.SubgraphResponse {
	v := &graph.SubgraphResponse{
		Version:   *body.Version,
		Root:      *body.Root,
		Truncated: *body.Truncated,
	}
	v.Nodes = make([]*graph.GraphNode, len(body.Nodes))
	for i, val := range body.Nodes {
		if val == nil {
			v.Nodes[i] = nil
			continue
		}
		v.Nodes[i] = unmarshalGraphNodeResponseBodyToGraphGraphNode(val)
	}
	v.Edges = make([]*graph.GraphEdge, len(body.Edges))
	for i, val := range body.Edges {
		if val == nil {
			v.Edges[i] = nil
			continue
		}
		v.Edges[i] = unmarshalGraphEdgeResponseBodyToGraphGraphEdge(val)
	}

	return v
}

// NewPostSubgraphBadRequest builds a graph service post_subgraph endpoint
// bad_request error.
func NewPostSubgraphBadRequest(body string) graph.BadRequest {
	v := graph.BadRequest(body)

	return v
}

// ValidateGetMetadataResponseBody runs the validations defined on
// get_metadata_response_body
func ValidateGetMetadataResponseBody(body *GetMetadataResponseBody) (err error) {
	if body.NodeTypes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_types", "body"))
	}
	if body.EdgeTypes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("edge_types", "body"))
	}
	if body.RankMetrics == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("rank_metrics", "body"))
	}
	return
}

// ValidatePostSubgraphResponseBody runs the validations defined on
// post_subgraph_response_body
func ValidatePostSubgraphResponseBody(body *PostSubgraphResponseBody) (err error) {
	if body.Version == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("version", "body"))
	}
	if body.Root == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("root", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.Edges == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("edges", "body"))
	}
	if body.Truncated == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("truncated", "body"))
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateGraphNodeResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Edges {
		if e != nil {
			if err2 := ValidateGraphEdgeResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateGraphNodeResponseBody runs the validations defined on
// GraphNodeResponseBody
func ValidateGraphNodeResponseBody(body *GraphNodeResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	if body.Label == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("label", "body"))
	}
	return
}

// ValidateGraphEdgeResponseBody runs the validations defined on
// GraphEdgeResponseBody
func ValidateGraphEdgeResponseBody(body *GraphEdgeResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.From == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("from", "body"))
	}
	if body.To == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("to", "body"))
	}
	if body.Directed == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("directed", "body"))
	}
	return
}

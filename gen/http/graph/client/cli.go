// Code generated by goa v3.24.1, DO NOT EDIT.
//
// graph HTTP client CLI support package
//
// Command:
// $ goa gen github.com/aditnikel/grapgraph/design

package client

import (
	"encoding/json"
	"fmt"

	graph "github.com/aditnikel/grapgraph/gen/graph"
	goa "goa.design/goa/v3/pkg"
)

// BuildPostSubgraphPayload builds the payload for the graph post_subgraph
// endpoint from CLI flags.
func BuildPostSubgraphPayload(graphPostSubgraphBody string) (*graph.SubgraphRequest, error) {
	var err error
	var body PostSubgraphRequestBody
	{
		err = json.Unmarshal([]byte(graphPostSubgraphBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"edge_types\": [\n         \"PAYMENT\",\n         \"LOGIN\"\n      ],\n      \"hops\": 2,\n      \"limit\": {\n         \"max_edges\": 100,\n         \"max_nodes\": 50\n      },\n      \"root\": {\n         \"key\": \"u_123\",\n         \"type\": \"USER\"\n      },\n      \"time_window_ms\": 2592000000\n   }'")
		}
		if body.Root == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("root", "body"))
		}
		if body.Limit == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("limit", "body"))
		}
		if body.Hops < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.hops", body.Hops, 1, true))
		}
		if body.Hops > 3 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.hops", body.Hops, 3, false))
		}
		if body.TimeWindowMs < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.time_window_ms", body.TimeWindowMs, 0, true))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &graph.SubgraphRequest{
		Hops:         body.Hops,
		TimeWindowMs: body.TimeWindowMs,
	}
	if body.Root != nil {
		v.Root = &struct {
			// Type of the root node (usually USER).
			Type string
			// The unique key of the root node.
			Key string
		}{
			Type: body.Root.Type,
			Key:  body.Root.Key,
		}
	}
	{
		var zero int
		if v.Hops == zero {
			v.Hops = 2
		}
	}
	if body.EdgeTypes != nil {
		v.EdgeTypes = make([]string, len(body.EdgeTypes))
		for i, val := range body.EdgeTypes {
			v.EdgeTypes[i] = val
		}
	}
	{
		var zero int64
		if v.TimeWindowMs == zero {
			v.TimeWindowMs = 0
		}
	}
	if body.Limit != nil {
		v.Limit = &struct {
			// Maximum number of nodes to return.
			MaxNodes int
			// Maximum number of edges to return.
			MaxEdges int
		}{
			MaxNodes: body.Limit.MaxNodes,
			MaxEdges: body.Limit.MaxEdges,
		}
	}

	return v, nil
}

// BuildPostManualEdgePayload builds the payload for the graph post_manual_edge
// endpoint from CLI flags.
func BuildPostManualEdgePayload(graphPostManualEdgeBody string) (*graph.ManualEdgeRequest, error) {
	var err error
	var body PostManualEdgeRequestBody
	{
		err = json.Unmarshal([]byte(graphPostManualEdgeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"edge_type\": \"MANUAL\",\n      \"from\": {\n         \"key\": \"u_123\",\n         \"type\": \"USER\"\n      },\n      \"to\": {\n         \"key\": \"u_123\",\n         \"type\": \"USER\"\n      }\n   }'")
		}
		if body.From == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("from", "body"))
		}
		if body.To == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("to", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &graph.ManualEdgeRequest{
		EdgeType: body.EdgeType,
	}
	if body.From != nil {
		v.From = marshalNodeRefRequestBodyToGraphNodeRef(body.From)
	}
	if body.To != nil {
		v.To = marshalNodeRefRequestBodyToGraphNodeRef(body.To)
	}

	return v, nil
}

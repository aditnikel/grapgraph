// Code generated by goa v3.24.1, DO NOT EDIT.
//
// graph HTTP server types
//
// Command:
// $ goa gen github.com/aditnikel/grapgraph/design

package server

import (
	graph "github.com/aditnikel/grapgraph/gen/graph"
	goa "goa.design/goa/v3/pkg"
)

// PostSubgraphRequestBody is the type of the "graph" service "post_subgraph"
// endpoint HTTP request body.
type PostSubgraphRequestBody struct {
	// The starting node for the traversal.
	Root *struct {
		// Type of the root node (usually USER).
		Type *string `form:"type" json:"type" xml:"type"`
		// The unique key of the root node.
		Key *string `form:"key" json:"key" xml:"key"`
	} `form:"root,omitempty" json:"root,omitempty" xml:"root,omitempty"`
	// Number of hops to traverse (>=1).
	Hops *int `form:"hops,omitempty" json:"hops,omitempty" xml:"hops,omitempty"`
	// Filter to only include these relationship types.
	EdgeTypes []string `form:"edge_types,omitempty" json:"edge_types,omitempty" xml:"edge_types,omitempty"`
	// Only include edges with at least this event_count. Set to 0 to disable.
	MinEventCount *int `form:"min_event_count,omitempty" json:"min_event_count,omitempty" xml:"min_event_count,omitempty"`
	// Only include edges observed within the last N milliseconds. Omit or set to 0
	// for all time.
	TimeWindowMs *int64 `form:"time_window_ms,omitempty" json:"time_window_ms,omitempty" xml:"time_window_ms,omitempty"`
	// Resource budget for the response.
	Limit *struct {
		// Maximum number of nodes to return.
		MaxNodes *int `form:"max_nodes" json:"max_nodes" xml:"max_nodes"`
		// Maximum number of edges to return.
		MaxEdges *int `form:"max_edges" json:"max_edges" xml:"max_edges"`
	} `form:"limit,omitempty" json:"limit,omitempty" xml:"limit,omitempty"`
}

// PostManualEdgeRequestBody is the type of the "graph" service
// "post_manual_edge" endpoint HTTP request body.
type PostManualEdgeRequestBody struct {
	// Source node.
	From *NodeRefRequestBody `form:"from,omitempty" json:"from,omitempty" xml:"from,omitempty"`
	// Target node.
	To *NodeRefRequestBody `form:"to,omitempty" json:"to,omitempty" xml:"to,omitempty"`
	// Relationship type (e.g. PAYMENT, MANUAL).
	EdgeType *string `form:"edge_type,omitempty" json:"edge_type,omitempty" xml:"edge_type,omitempty"`
}

// GetMetadataResponseBody is the type of the "graph" service "get_metadata"
// endpoint HTTP response body.
type GetMetadataResponseBody struct {
	// All valid entity types.
	NodeTypes []string `form:"node_types" json:"node_types" xml:"node_types"`
	// All valid event types.
	EdgeTypes []string `form:"edge_types" json:"edge_types" xml:"edge_types"`
}

// PostSubgraphResponseBody is the type of the "graph" service "post_subgraph"
// endpoint HTTP response body.
type PostSubgraphResponseBody struct {
	// Format version of the response.
	Version string `form:"version" json:"version" xml:"version"`
	// The ID of the requested starting node.
	Root string `form:"root" json:"root" xml:"root"`
	// List of all entities in the network.
	Nodes []*GraphNodeResponseBody `form:"nodes" json:"nodes" xml:"nodes"`
	// List of all connections found.
	Edges []*GraphEdgeResponseBody `form:"edges" json:"edges" xml:"edges"`
	// Indicates if the result was clipped by performance budgets.
	Truncated bool `form:"truncated" json:"truncated" xml:"truncated"`
}

// PostManualEdgeResponseBody is the type of the "graph" service
// "post_manual_edge" endpoint HTTP response body.
type PostManualEdgeResponseBody struct {
	// Unique ID for the specific relationship.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of connection (e.g. PAYMENT).
	Type string `form:"type" json:"type" xml:"type"`
	// ID of the source node.
	From string `form:"from" json:"from" xml:"from"`
	// ID of the target node.
	To string `form:"to" json:"to" xml:"to"`
	// Whether the relationship has a specific flow direction.
	Directed bool `form:"directed" json:"directed" xml:"directed"`
	// Whether the relationship was manually added.
	Manual bool `form:"manual" json:"manual" xml:"manual"`
}

// GraphNodeResponseBody is used to define fields on response body types.
type GraphNodeResponseBody struct {
	// Stable ID generated for visualization.
	ID string `form:"id" json:"id" xml:"id"`
	// The category of the entity.
	Type string `form:"type" json:"type" xml:"type"`
	// The domain-specific key (e.g. u_123).
	Key string `form:"key" json:"key" xml:"key"`
	// Human-friendly display name.
	Label string `form:"label" json:"label" xml:"label"`
	// Additional key-value properties.
	Props map[string]any `form:"props,omitempty" json:"props,omitempty" xml:"props,omitempty"`
}

// GraphEdgeResponseBody is used to define fields on response body types.
type GraphEdgeResponseBody struct {
	// Unique ID for the specific relationship.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of connection (e.g. PAYMENT).
	Type string `form:"type" json:"type" xml:"type"`
	// ID of the source node.
	From string `form:"from" json:"from" xml:"from"`
	// ID of the target node.
	To string `form:"to" json:"to" xml:"to"`
	// Whether the relationship has a specific flow direction.
	Directed bool `form:"directed" json:"directed" xml:"directed"`
	// Whether the relationship was manually added.
	Manual bool `form:"manual" json:"manual" xml:"manual"`
}

// NodeRefRequestBody is used to define fields on request body types.
type NodeRefRequestBody struct {
	// Type of the node.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The unique key of the node.
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
}

// NewGetMetadataResponseBody builds the HTTP response body from the result of
// the "get_metadata" endpoint of the "graph" service.
func NewGetMetadataResponseBody(res *graph.MetadataResponse) *GetMetadataResponseBody {
	body := &GetMetadataResponseBody{}
	if res.NodeTypes != nil {
		body.NodeTypes = make([]string, len(res.NodeTypes))
		for i, val := range res.NodeTypes {
			body.NodeTypes[i] = val
		}
	} else {
		body.NodeTypes = []string{}
	}
	if res.EdgeTypes != nil {
		body.EdgeTypes = make([]string, len(res.EdgeTypes))
		for i, val := range res.EdgeTypes {
			body.EdgeTypes[i] = val
		}
	} else {
		body.EdgeTypes = []string{}
	}
	return body
}

// NewPostSubgraphResponseBody builds the HTTP response body from the result of
// the "post_subgraph" endpoint of the "graph" service.
func NewPostSubgraphResponseBody(res *graph.SubgraphResponse) *PostSubgraphResponseBody {
	body := &PostSubgraphResponseBody{
		Version:   res.Version,
		Root:      res.Root,
		Truncated: res.Truncated,
	}
	if res.Nodes != nil {
		body.Nodes = make([]*GraphNodeResponseBody, len(res.Nodes))
		for i, val := range res.Nodes {
			if val == nil {
				body.Nodes[i] = nil
				continue
			}
			body.Nodes[i] = marshalGraphGraphNodeToGraphNodeResponseBody(val)
		}
	} else {
		body.Nodes = []*GraphNodeResponseBody{}
	}
	if res.Edges != nil {
		body.Edges = make([]*GraphEdgeResponseBody, len(res.Edges))
		for i, val := range res.Edges {
			if val == nil {
				body.Edges[i] = nil
				continue
			}
			body.Edges[i] = marshalGraphGraphEdgeToGraphEdgeResponseBody(val)
		}
	} else {
		body.Edges = []*GraphEdgeResponseBody{}
	}
	return body
}

// NewPostManualEdgeResponseBody builds the HTTP response body from the result
// of the "post_manual_edge" endpoint of the "graph" service.
func NewPostManualEdgeResponseBody(res *graph.GraphEdge) *PostManualEdgeResponseBody {
	body := &PostManualEdgeResponseBody{
		ID:       res.ID,
		Type:     res.Type,
		From:     res.From,
		To:       res.To,
		Directed: res.Directed,
		Manual:   res.Manual,
	}
	return body
}

// NewPostSubgraphSubgraphRequest builds a graph service post_subgraph endpoint
// payload.
func NewPostSubgraphSubgraphRequest(body *PostSubgraphRequestBody) *graph.SubgraphRequest {
	v := &graph.SubgraphRequest{}
	if body.Hops != nil {
		v.Hops = *body.Hops
	}
	if body.MinEventCount != nil {
		v.MinEventCount = *body.MinEventCount
	}
	if body.TimeWindowMs != nil {
		v.TimeWindowMs = *body.TimeWindowMs
	}
	v.Root = &struct {
		// Type of the root node (usually USER).
		Type string
		// The unique key of the root node.
		Key string
	}{
		Type: *body.Root.Type,
		Key:  *body.Root.Key,
	}
	if body.Hops == nil {
		v.Hops = 2
	}
	if body.EdgeTypes != nil {
		v.EdgeTypes = make([]string, len(body.EdgeTypes))
		for i, val := range body.EdgeTypes {
			v.EdgeTypes[i] = val
		}
	}
	if body.MinEventCount == nil {
		v.MinEventCount = 0
	}
	if body.TimeWindowMs == nil {
		v.TimeWindowMs = 0
	}
	v.Limit = &struct {
		// Maximum number of nodes to return.
		MaxNodes int
		// Maximum number of edges to return.
		MaxEdges int
	}{
		MaxNodes: *body.Limit.MaxNodes,
		MaxEdges: *body.Limit.MaxEdges,
	}

	return v
}

// NewPostManualEdgeManualEdgeRequest builds a graph service post_manual_edge
// endpoint payload.
func NewPostManualEdgeManualEdgeRequest(body *PostManualEdgeRequestBody) *graph.ManualEdgeRequest {
	v := &graph.ManualEdgeRequest{
		EdgeType: *body.EdgeType,
	}
	v.From = unmarshalNodeRefRequestBodyToGraphNodeRef(body.From)
	v.To = unmarshalNodeRefRequestBodyToGraphNodeRef(body.To)

	return v
}

// ValidatePostSubgraphRequestBody runs the validations defined on
// post_subgraph_request_body
func ValidatePostSubgraphRequestBody(body *PostSubgraphRequestBody) (err error) {
	if body.Root == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("root", "body"))
	}
	if body.Limit == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("limit", "body"))
	}
	if body.Root != nil {
		if body.Root.Type == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("type", "body.root"))
		}
		if body.Root.Key == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("key", "body.root"))
		}
	}
	if body.Hops != nil {
		if *body.Hops < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.hops", *body.Hops, 1, true))
		}
	}
	if body.MinEventCount != nil {
		if *body.MinEventCount < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.min_event_count", *body.MinEventCount, 0, true))
		}
	}
	if body.TimeWindowMs != nil {
		if *body.TimeWindowMs < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.time_window_ms", *body.TimeWindowMs, 0, true))
		}
	}
	if body.Limit != nil {
		if body.Limit.MaxNodes == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("max_nodes", "body.limit"))
		}
		if body.Limit.MaxEdges == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("max_edges", "body.limit"))
		}
	}
	return
}

// ValidatePostManualEdgeRequestBody runs the validations defined on
// post_manual_edge_request_body
func ValidatePostManualEdgeRequestBody(body *PostManualEdgeRequestBody) (err error) {
	if body.From == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("from", "body"))
	}
	if body.To == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("to", "body"))
	}
	if body.EdgeType == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("edge_type", "body"))
	}
	if body.From != nil {
		if err2 := ValidateNodeRefRequestBody(body.From); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.To != nil {
		if err2 := ValidateNodeRefRequestBody(body.To); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateNodeRefRequestBody runs the validations defined on NodeRefRequestBody
func ValidateNodeRefRequestBody(body *NodeRefRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	return
}

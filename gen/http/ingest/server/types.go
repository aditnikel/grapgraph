// Code generated by goa v3.24.1, DO NOT EDIT.
//
// ingest HTTP server types
//
// Command:
// $ goa gen github.com/aditnikel/grapgraph/design

package server

import (
	ingest "github.com/aditnikel/grapgraph/gen/ingest"
	goa "goa.design/goa/v3/pkg"
)

// PostEventRequestBody is the type of the "ingest" service "post_event"
// endpoint HTTP request body.
type PostEventRequestBody struct {
	// List of events to ingest in-order.
	Events []*CustomerEventRequestBody `form:"events,omitempty" json:"events,omitempty" xml:"events,omitempty"`
}

// PostEventResponseBody is the type of the "ingest" service "post_event"
// endpoint HTTP response body.
type PostEventResponseBody struct {
	// Whether all events were processed successfully.
	Accepted bool `form:"accepted" json:"accepted" xml:"accepted"`
	// Number of events accepted in this batch.
	AcceptedCount int `form:"accepted_count" json:"accepted_count" xml:"accepted_count"`
	// Number of events rejected in this batch.
	FailedCount int `form:"failed_count" json:"failed_count" xml:"failed_count"`
}

// CustomerEventRequestBody is used to define fields on request body types.
type CustomerEventRequestBody struct {
	// Unique identifier of the user (e.g. u_123).
	UserID *string `form:"user_id,omitempty" json:"user_id,omitempty" xml:"user_id,omitempty"`
	// Target merchant ID or card MPAN.
	MerchantIDMpan *string `form:"merchant_id_mpan,omitempty" json:"merchant_id_mpan,omitempty" xml:"merchant_id_mpan,omitempty"`
	// The type of event (PAYMENT, LOGIN, WITHDRAWAL, etc).
	EventType *string `form:"event_type,omitempty" json:"event_type,omitempty" xml:"event_type,omitempty"`
	// Timestamp of the activity (RFC3339 string or Epoch MS).
	EventTimestamp any `form:"event_timestamp,omitempty" json:"event_timestamp,omitempty" xml:"event_timestamp,omitempty"`
	// Monetary value of the transaction.
	TotalTransactionAmount *float64 `form:"total_transaction_amount,omitempty" json:"total_transaction_amount,omitempty" xml:"total_transaction_amount,omitempty"`
	// Unique hardware ID where the activity originated.
	DeviceID *string `form:"device_id,omitempty" json:"device_id,omitempty" xml:"device_id,omitempty"`
	// Method used (VISA, CRYPTO, etc).
	PaymentMethod *string `form:"payment_method,omitempty" json:"payment_method,omitempty" xml:"payment_method,omitempty"`
	// The bank that issued the instrument.
	IssuingBank *string `form:"issuing_bank,omitempty" json:"issuing_bank,omitempty" xml:"issuing_bank,omitempty"`
	// Blockchain wallet address if applicable.
	WalletAddress *string `form:"wallet_address,omitempty" json:"wallet_address,omitempty" xml:"wallet_address,omitempty"`
	// Crypto exchange name if applicable.
	Exchange *string `form:"exchange,omitempty" json:"exchange,omitempty" xml:"exchange,omitempty"`
	// Remote IP address (not stored directly in graph).
	IPAddress *string `form:"ip_address,omitempty" json:"ip_address,omitempty" xml:"ip_address,omitempty"`
}

// NewPostEventResponseBody builds the HTTP response body from the result of
// the "post_event" endpoint of the "ingest" service.
func NewPostEventResponseBody(res *ingest.BulkIngestResponse) *PostEventResponseBody {
	body := &PostEventResponseBody{
		Accepted:      res.Accepted,
		AcceptedCount: res.AcceptedCount,
		FailedCount:   res.FailedCount,
	}
	return body
}

// NewPostEventBulkCustomerEvents builds a ingest service post_event endpoint
// payload.
func NewPostEventBulkCustomerEvents(body *PostEventRequestBody) *ingest.BulkCustomerEvents {
	v := &ingest.BulkCustomerEvents{}
	v.Events = make([]*ingest.CustomerEvent, len(body.Events))
	for i, val := range body.Events {
		if val == nil {
			v.Events[i] = nil
			continue
		}
		v.Events[i] = unmarshalCustomerEventRequestBodyToIngestCustomerEvent(val)
	}

	return v
}

// ValidatePostEventRequestBody runs the validations defined on
// post_event_request_body
func ValidatePostEventRequestBody(body *PostEventRequestBody) (err error) {
	if body.Events == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("events", "body"))
	}
	if len(body.Events) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.events", body.Events, len(body.Events), 1, true))
	}
	for _, e := range body.Events {
		if e != nil {
			if err2 := ValidateCustomerEventRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateCustomerEventRequestBody runs the validations defined on
// CustomerEventRequestBody
func ValidateCustomerEventRequestBody(body *CustomerEventRequestBody) (err error) {
	if body.UserID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("user_id", "body"))
	}
	if body.EventType == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("event_type", "body"))
	}
	if body.EventTimestamp == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("event_timestamp", "body"))
	}
	return
}
